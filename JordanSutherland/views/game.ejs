<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaming</title>
    <style>
        html,
        body,
        canvas {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>
<script src="/socket.io/socket.io.js"></script>
<script>
    const socket = io();

    let users = [];
    let user = {
        name: '<%= user %>',
        userId: socket.id,
    };
    var availableCorners = [
        'bottom-left',
        'bottom-right',
        'top-left',
        'top-right',
    ];

    socket.on('corners', (data) => {
        availableCorners = data.corners;
    });
    socket.emit('new-user', user);
    socket.on('user-connected', data => {
        console.log(data.user.name + ' connected');
    });
    socket.on('user-disconnected', data => {
        console.log(data.user.name + ' disconnected');
    });
    socket.on('update', (data) => {
        // Update the local player list
        users = data.users;
    });

</script>

<body>
    <canvas id="canvas" height="100%" width="100%"></canvas>

</body>
<script>

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    window.onresize = function () {
        socket.emit('resize', {
            canvasWidth: canvas.width,
            canvasHeight: canvas.height,
            WIDTH: Math.floor(window.innerWidth / 3),
            HEIGHT: Math.floor(window.innerHeight / 3),
            HALF_WIDTH: Math.floor(window.innerWidth / 3) / 2,
            HALF_HEIGHT: Math.floor(window.innerHeight / 3) / 2,
        });
    }

    function onLoad() {
        socket.emit('resize', {
            canvasWidth: canvas.width,
            canvasHeight: canvas.height,
            WIDTH: Math.floor(window.innerWidth / 3),
            HEIGHT: Math.floor(window.innerHeight / 3),
            HALF_WIDTH: Math.floor(window.innerWidth / 3) / 2,
            HALF_HEIGHT: Math.floor(window.innerHeight / 3) / 2,
        });
    }

    //Raycasting Stuff  

    // 88888888ba                                                                        88                                ad88888ba                          ad88     ad88  
    // 88      "8b                                                                ,d     ""                               d8"     "8b  ,d                    d8"      d8"    
    // 88      ,8P                                                                88                                      Y8,          88                    88       88     
    // 88aaaaaa8P'  ,adPPYYba,  8b       d8   ,adPPYba,  ,adPPYYba,  ,adPPYba,  MM88MMM  88  8b,dPPYba,    ,adPPYb,d8     `Y8aaaaa,  MM88MMM  88       88  MM88MMM  MM88MMM  
    // 88""""88'    ""     `Y8  `8b     d8'  a8"     ""  ""     `Y8  I8[    ""    88     88  88P'   `"8a  a8"    `Y88       `"""""8b,  88     88       88    88       88     
    // 88    `8b    ,adPPPPP88   `8b   d8'   8b          ,adPPPPP88   `"Y8ba,     88     88  88       88  8b       88             `8b  88     88       88    88       88     
    // 88     `8b   88,    ,88    `8b,d8'    "8a,   ,aa  88,    ,88  aa    ]8I    88,    88  88       88  "8a,   ,d88     Y8a     a8P  88,    "8a,   ,a88    88       88     
    // 88      `8b  `"8bbdP"Y8      Y88'      `"Ybbd8"'  `"8bbdP"Y8  `"YbbdP"'    "Y888  88  88       88   `"YbbdP"Y8      "Y88888P"   "Y888   `"YbbdP'Y8    88       88     
    //                              d8'                                                                    aa,    ,88                                                        
    //                             d8'                                                                      "Y8bbdP"                                                         

    // FPS
    const FPS = 60;
    const cycleDelay = Math.floor(1000 / FPS);
    var oldCycleTime = 0;
    var cycleCount = 0;
    var fps_rate = '...';

    // map
    const MAP_SIZE = 32;
    const MAP_SCALE = 128;
    const MAP_RANGE = MAP_SCALE * MAP_SIZE;
    const MAP_SPEED = (MAP_SCALE / 2) / 10;
    var map = [
        1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    ];
    var showMap = false;

    // handle key down events
    document.addEventListener('keydown', function (event) {
        var key = event.keyCode;
        socket.emit('keydown', key);
    });
    document.addEventListener('keyup', function (event) {
        var key = event.keyCode;
        socket.emit('keyup', key);
        switch (key) {
            case 77: showMap = !showMap; break;
        }
    });

    // screen
    const WIDTH = Math.floor(window.innerWidth / 4), HALF_WIDTH = WIDTH / 2;
    const HEIGHT = Math.floor(window.innerHeight / 4), HALF_HEIGHT = HEIGHT / 2;

    // camera
    const DOUBLE_PI = Math.PI * 2;
    const FOV = Math.PI / 3;
    const HALF_FOV = FOV / 2;
    const STEP_ANGLE = FOV / WIDTH;

    // graphics
    const WALLS = [];

    // load wall textures
    for (var filename = 0; filename < 3; filename++) {
        var img = new Image();
        img.src = "static/walls/" + filename + ".png";
        WALLS.push(img);
    }

    // load empty question mark
    var emptyQuestion = new Image();
    emptyQuestion.src = "emptyQuestion.png";



    // Game Loop
    function gameLoop() {
        // Update FPS
        cycleCount++;
        if (cycleCount >= 60) cycleCount = 0;
        var startTime = Date.now();
        var cycleTime = startTime - oldCycleTime;
        oldCycleTime = startTime;
        if (cycleCount % 60 == 0) fps_rate = Math.floor(1000 / cycleTime);

        // Resize dynamically
        canvas.width = window.innerWidth / 2;
        canvas.height = window.innerHeight / 2;

        // Draw Background
        // Draw Background
        ctx.drawImage(WALLS[0], 0, 0, WIDTH * 4, HEIGHT); // Top half
        ctx.drawImage(WALLS[0], 0, HEIGHT, WIDTH * 4, HEIGHT); // Bottom half

        // Draw FPS
        ctx.fillStyle = 'black';
        ctx.font = '1vi Arial';
        ctx.fillText('FPS: ' + fps_rate, 5, 15);
        let temp = 15;
        for (user in users) {
            let itUser = users[user];
            ctx.fillText(users[user].name, 5, 30 + Object.keys(users).indexOf(users[user].name) * 15 + temp);
            temp += 15;
            switch (itUser.corner) {
                case "top-left":
                    cornerX = 0;
                    cornerY = 0;
                    break;
                case "top-right":
                    cornerX = canvas.width / 2;
                    cornerY = 0;
                    break;
                case "bottom-left":
                    cornerX = 0;
                    cornerY = canvas.height / 2;
                    break;
                case "bottom-right":
                    cornerX = canvas.width / 2;
                    cornerY = canvas.height / 2;
                    break;
                default:
                    cornerX = 0;
                    cornerY = 0;
                    break;
            }


            // Raycast other users
            var otherUserX = itUser.playerX;
            var otherUserY = itUser.playerY;
            var otherUserAngle = itUser.playerAngle;

            var otherCurrentAngle = otherUserAngle + HALF_FOV;
            var otherRayStartX = Math.floor(otherUserX / MAP_SCALE) * MAP_SCALE;
            var otherRayStartY = Math.floor(otherUserY / MAP_SCALE) * MAP_SCALE;

            for (var otherRay = 0; otherRay < WIDTH; otherRay++) {
                var otherCurrentSin = Math.sin(otherCurrentAngle); otherCurrentSin = otherCurrentSin ? otherCurrentSin : .000001;
                var otherCurrentCos = Math.cos(otherCurrentAngle); otherCurrentCos = otherCurrentCos ? otherCurrentCos : .000001;

                // Vertical Raycast intersection
                var otherRayEndX, otherRayEndY, otherRayDirectionX, otherVerticalDepth, otherTextureEndY, otherTextureY;
                if (otherCurrentSin > 0) { otherRayEndX = otherRayStartX + MAP_SCALE; otherRayDirectionX = 1 }
                else { otherRayEndX = otherRayStartX; otherRayDirectionX = -1 }
                for (var otherOffset = 0; otherOffset < MAP_RANGE; otherOffset += MAP_SCALE) {
                    otherVerticalDepth = (otherRayEndX - otherUserX) / otherCurrentSin;
                    otherRayEndY = otherUserY + otherVerticalDepth * otherCurrentCos;
                    var otherMapTargetX = Math.floor(otherRayEndX / MAP_SCALE);
                    var otherMapTargetY = Math.floor(otherRayEndY / MAP_SCALE);
                    if (otherCurrentSin <= 0) otherMapTargetX += otherRayDirectionX;
                    var otherTargetSquare = otherMapTargetY * MAP_SIZE + otherMapTargetX;
                    if (otherTargetSquare < 0 || otherTargetSquare >= map.length - 1) break;
                    if (map[otherTargetSquare] != 0) { otherTextureY = map[otherTargetSquare]; break; };
                    otherRayEndX += otherRayDirectionX * MAP_SCALE;
                }
                otherTextureEndY = otherRayEndY;

                // Horizontal Raycast intersection
                var otherRayEndY, otherRayEndX, otherRayDirectionY, otherHorizontalDepth, otherTextureEndX, otherTextureX;
                if (otherCurrentCos > 0) { otherRayEndY = otherRayStartY + MAP_SCALE; otherRayDirectionY = 1 }
                else { otherRayEndY = otherRayStartY; otherRayDirectionY = -1 }
                for (var otherOffset = 0; otherOffset < MAP_RANGE; otherOffset += MAP_SCALE) {
                    otherHorizontalDepth = (otherRayEndY - otherUserY) / otherCurrentCos;
                    otherRayEndX = otherUserX + otherHorizontalDepth * otherCurrentSin;
                    var otherMapTargetX = Math.floor(otherRayEndX / MAP_SCALE);
                    var otherMapTargetY = Math.floor(otherRayEndY / MAP_SCALE);
                    if (otherCurrentCos <= 0) otherMapTargetY += otherRayDirectionY;
                    var otherTargetSquare = otherMapTargetY * MAP_SIZE + otherMapTargetX;
                    if (otherTargetSquare < 0 || otherTargetSquare >= map.length - 1) break;
                    if (map[otherTargetSquare] != 0) { otherTextureX = map[otherTargetSquare]; break; };
                    otherRayEndY += otherRayDirectionY * MAP_SCALE;
                }
                otherTextureEndX = otherRayEndX;

                var otherDepth = otherVerticalDepth < otherHorizontalDepth ? otherVerticalDepth : otherHorizontalDepth;
                var otherTextureImage = otherVerticalDepth < otherHorizontalDepth ? otherTextureY : otherTextureX;
                var otherTextureOffset = otherVerticalDepth < otherHorizontalDepth ? otherTextureEndY : otherTextureEndX;
                otherTextureOffset = otherTextureOffset - Math.floor(otherTextureOffset / MAP_SCALE) * MAP_SCALE;
                otherDepth *= Math.cos(otherUserAngle - otherCurrentAngle);
                var otherWallHeight = Math.min(Math.floor(MAP_SCALE * 300 / (otherDepth + 0.0001)), 50000);

                if (!otherTextureImage) {
                    ctx.fillStyle = 'black';
                    let drawHeight = otherWallHeight;
                    let drawY = cornerY + (HALF_HEIGHT - otherWallHeight / 2);
                    if (drawY < cornerY) {
                        drawHeight -= (cornerY - drawY);
                        drawY = cornerY;
                    }
                    if (drawY + drawHeight > cornerY + canvas.height / 2) {
                        drawHeight = (cornerY + canvas.height / 2) - drawY;
                    }
                    ctx.fillRect(cornerX + otherRay, drawY, 1, drawHeight);
                } else {
                    let drawHeight = otherWallHeight;
                    let drawY = cornerY + (HALF_HEIGHT - Math.floor(otherWallHeight / 2));
                    if (drawY < cornerY) {
                        drawHeight -= (cornerY - drawY);
                        drawY = cornerY;
                    }
                    if (drawY + drawHeight > cornerY + canvas.height / 2) {
                        drawHeight = (cornerY + canvas.height / 2) - drawY;
                    }
                    ctx.drawImage(
                        WALLS[otherTextureImage],
                        otherTextureOffset,
                        0,
                        1,
                        128,
                        cornerX + otherRay,
                        drawY,
                        1,
                        drawHeight,
                    );
                }




                otherCurrentAngle -= STEP_ANGLE;
            }

            let mainCornerX = 0;
            let mainCornerY = 0;

            // User Map Stuff
            if (itUser.userId == socket.id) {
                // Calculate map & player offsets
                var mapOffsetX = Math.floor(canvas.width / 2 - HALF_WIDTH);
                var mapOffsetY = Math.floor(canvas.height / 2 - HALF_HEIGHT);
                var playerMapX = (itUser.playerX / MAP_SCALE) * 5 + mapOffsetX;
                var playerMapY = (itUser.playerY / MAP_SCALE) * 5 + mapOffsetY;

                // Draw 2d map
                if (showMap) {
                    for (var row = 0; row < MAP_SIZE; row++) {
                        for (var col = 0; col < MAP_SIZE; col++) {
                            var square = row * MAP_SIZE + col;
                            if (map[square] != 0) {
                                ctx.fillStyle = 'green';
                                ctx.fillRect(cornerX + col * 5, cornerY + row * 5, 5, 5);
                            } else {
                                ctx.fillStyle = '#aaa';
                                ctx.fillRect(cornerX + col * 5, cornerY + row * 5, 5, 5);
                            }
                        }
                    }

                    // Draw user on map
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(cornerX + itUser.playerX / MAP_SCALE * 5, cornerY + itUser.playerY / MAP_SCALE * 5, 3, 0, DOUBLE_PI, true);
                    ctx.fill();
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(cornerX + itUser.playerX / MAP_SCALE * 5, cornerY + itUser.playerY / MAP_SCALE * 5);
                    ctx.lineTo(cornerX + itUser.playerX / MAP_SCALE * 5 + Math.sin(itUser.playerAngle) * 5, cornerY + itUser.playerY / MAP_SCALE * 5 + Math.cos(itUser.playerAngle) * 5);
                    ctx.stroke();
                    mainCornerX = cornerX;
                    mainCornerY = cornerY;

                }
            } else {
                if (showMap) {
                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(mainCornerX + itUser.playerX / MAP_SCALE * 5, mainCornerY + itUser.playerY / MAP_SCALE * 5, 3, 0, DOUBLE_PI, true);
                    ctx.fill();
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(mainCornerX + itUser.playerX / MAP_SCALE * 5, mainCornerY + itUser.playerY / MAP_SCALE * 5);
                    ctx.lineTo(mainCornerX + itUser.playerX / MAP_SCALE * 5 + Math.sin(itUser.playerAngle) * 5, mainCornerY + itUser.playerY / MAP_SCALE * 5 + Math.cos(itUser.playerAngle) * 5);
                    ctx.stroke();
                }
            }


            // Border
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(cornerX, cornerY, canvas.width / 2, canvas.height / 2);
            for (availableCorner in availableCorners) {
                switch (availableCorners[availableCorner]) {
                    case "top-left":
                        ctx.drawImage(emptyQuestion, 0, 0, canvas.width / 2, canvas.height / 2);
                        break;
                    case "top-right":
                        ctx.drawImage(emptyQuestion, canvas.width / 2, 0, canvas.width / 2, canvas.height / 2);
                        break;
                    case "bottom-left":
                        ctx.drawImage(emptyQuestion, 0, canvas.height / 2, canvas.width / 2, canvas.height / 2);
                        break;
                    case "bottom-right":
                        ctx.drawImage(emptyQuestion, canvas.width / 2, canvas.height / 2, canvas.width / 2, canvas.height / 2);
                        break;
                }
            }
        }



        //inf loop
        setTimeout(gameLoop, cycleDelay);

    } window.onload = function () { gameLoop(); onLoad(); };
</script>

</html>